#!/usr/bin/env groovy

// This file was generated by the CI/CD Wizard version 1.0.421.
// See the user guide for information on how to customize and use this file.

pipeline {
    environment {
        BUILD_CONFIGURATION = 'sam_e54_xpro'
        SUPPORT_SCRIPT_REPO = 'https://raw.githubusercontent.com/MicrochipTech/cicd-assistant/main'
        HARDWARE_TEST_BUILD_CONFIGURATION = 'sam_e54_xpro'
        HARDWARE_TEST_RESULT_JUNIT = 'hw-test-junit.xml'
        HARDWARE_TEST_SERIAL_OUTPUT_FILE = 'sam_e54_xpro.X/hardware_test_serial_output.txt'
    }

    agent {
        // Build agent label to select build
        // agent for orchestrator job.
        label 'docker'
    }

    stages {
        // The build step will build the source code using the
        // selected compiler to verify that it builds correctly,
        // and store the build artefacts for later use
        stage('Build') {
            agent {
                dockerfile  {
                    // Build agent label to select build agent
                    // to host docker container.
                    // NOTE: This must be a linux based container.
                    label 'docker'
                    filename 'sam_e54_xpro.X/Dockerfile'

                    registryUrl "https://registry.hub.docker.com/"
                }
            }
            steps {
                sh(
                    label: 'Generate build makefiles',
                    script: "prjMakefilesGenerator.sh -v -f ./sam_e54_xpro.X/@${env.BUILD_CONFIGURATION}"
                )
                sh(
                    label: 'Running Makefile',
                    script: """
                            rm -rf ./sam_e54_xpro.X/build
                            rm -rf ./sam_e54_xpro.X/dist
                            cd sam_e54_xpro.X
                            make clean
                            make CONF=${env.BUILD_CONFIGURATION}
                            """
                )

                // Store build artefacts for later
                stash name: 'build',
                      includes: 'dist/**/*',
                      allowEmpty: true
            }
        }
        stage('Hardware Test') {
            agent {
                dockerfile  {
                    // Build agent label to select build agent
                    // to host docker container.
                    // NOTE: This must be a linux based container.
                    label 'docker'
                    filename 'sam_e54_xpro.X/Dockerfile'

                    registryUrl "https://registry.hub.docker.com/"
                }
            }
            environment {
                HARDWARE_TEST_TOOL_IP = 'xxx.xxx.xxx.xxx'
                HARDWARE_TEST_TOOL_SERIAL_PORT = 'xxxx'
                HARDWARE_TEST_MDB_SCRIPT_FILE = 'sam_e54_xpro.X/mdb-hardware-script.txt'
                HARDWARE_TEST_BINARY_FILE = './sam_e54_xpro.X/dist/build.elf'
            }
            steps {
                sh(
                    label: 'Generate hardware test makefiles',
                    script: "prjMakefilesGenerator.sh -v -f ./sam_e54_xpro.X/@${env.HARDWARE_TEST_BUILD_CONFIGURATION}"
                )
                sh(
                    label: 'Running Makefile',
                    script: """
                            rm -rf ./sam_e54_xpro.X/build
                            rm -rf ./sam_e54_xpro.X/dist
                            cd sam_e54_xpro.X
                            make clean
                            make CONF=${env.HARDWARE_TEST_BUILD_CONFIGURATION}
                            """
                )
                sh(
                    label: 'Copy binary file to location expected by MDB script',
                    script: """
                            rm -rf ${env.HARDWARE_TEST_BINARY_FILE}
                            cp ./sam_e54_xpro.X/dist/**/**/*.elf ${env.HARDWARE_TEST_BINARY_FILE}
                            ls -l ${env.HARDWARE_TEST_BINARY_FILE}
                            """
                )
                sh(
                    label: 'Start capturing serial output',
                    script: """
                            curl ${env.SUPPORT_SCRIPT_REPO}/socket2file.js -o socket2file.js
                            rm -rf ${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE}
                            node socket2file.js ${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE} \
                            ${env.HARDWARE_TEST_TOOL_IP} ${env.HARDWARE_TEST_TOOL_SERIAL_PORT} &
                            """
                )
                sh(
                    label: 'Run MDB script on hardware',
                    script: """
                            mdb.sh ${env.HARDWARE_TEST_MDB_SCRIPT_FILE}
                            rm -rf ${env.HARDWARE_TEST_BINARY_FILE}
                            """
                )
                sh(
                    label: 'End capturing serial output',
                    script: """
                            pkill -f "node socket2file.js"
                            """
                )
                sh(
                    label: 'Convert serial output to junit test result (xml)',
                    script: """
                            if [ -f "${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE}" ]; then
                                echo "Serial communication captured during hardware test (raw):"
                                cat ${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE}

                                curl ${env.SUPPORT_SCRIPT_REPO}/unity2junit.js -o unity2junit.js
                                rm -rf ${env.HARDWARE_TEST_RESULT_JUNIT}
                                node unity2junit.js ${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE} ${env.HARDWARE_TEST_RESULT_JUNIT}
                            else
                                echo "Warning: The hardware test did not generate any serial output file"
                            fi
                            """
                )

                // Store hardware test artefacts for later
                stash name: 'hardware_test',
                      includes: "${env.HARDWARE_TEST_RESULT_JUNIT}, ${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE}, ${env.HARDWARE_TEST_COVERAGE_DIR}/**/*",
                      allowEmpty: true
            }
        }
        stage('Publish') {
            steps {
                // Retrieve build artefacts
                unstash 'build'
                dir('dist') {
                    zip archive: true,
                        glob: '**/*',
                        overwrite: true,
                        zipFile: 'dist.zip'
                }
                // Retrieve hardware test artefacts
                unstash 'hardware_test'
                // Publish junit test results
                junit allowEmptyResults: true,
                      testResults: "${env.HARDWARE_TEST_RESULT_JUNIT}"
                // Publish serial output
                archiveArtifacts artifacts: "${env.HARDWARE_TEST_SERIAL_OUTPUT_FILE}"
               recordIssues(tools: [gcc()])
            }
        }
    }
    post {
        // Optional: Add post build actions for various build outcomes.
        // NOTE: The order in which post build actions is executed
        // is fixed (always, changed, success, unstable, failure)
        // regardless of how they appear below.

        // Actions to perform regardless of outcome
        always {
            // Clean workspace after build
            cleanWs()
        }

        // changed { /* Actions to perform when outcome state was changed since last build */ }
        // success { /* Actions to perform for builds that succeed */ }
        // unstable { /* Actions to perform for builds marked as unstable */ }
        // failure { /* Actions to perform for failed builds */ }
    }
}
